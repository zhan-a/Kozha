<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bridgn ‚Äî Translator</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;1,9..40,300&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://vhg.cmp.uea.ac.uk/tech/jas/vhg2024/cwa/cwasa.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script defer src="https://vhg.cmp.uea.ac.uk/tech/jas/vhg2024/cwa/allcsa.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@xenova/transformers@3.2.1/dist/transformers.min.js" crossorigin="anonymous"></script>
  <script defer src="https://unpkg.com/compromise@14.12.0/builds/compromise.min.js" crossorigin="anonymous"></script>
  <script defer src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js" crossorigin="anonymous"></script>

  <style>
    :root {
      --ink: #1a1612;
      --ink-2: #3d3630;
      --ink-3: #7a6f65;
      --paper: #f5f1eb;
      --paper-2: #ede8e0;
      --paper-3: #e4ddd3;
      --accent: #c96a2e;
      --accent-2: #e8843e;
      --accent-light: #f5e4d6;
      --green: #2d6a4f;
      --green-light: #d4edda;
      --border: rgba(26,22,18,0.12);
      --radius: 16px;
      --radius-sm: 10px;
      --sidebar: 260px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'DM Sans', sans-serif;
      background: var(--paper);
      color: var(--ink);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ‚îÄ‚îÄ NAV ‚îÄ‚îÄ */
    .app-nav {
      position: sticky; top: 0; z-index: 100;
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 32px;
      height: 56px;
      background: rgba(245,241,235,0.92);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
    }
    .nav-logo {
      font-family: 'Instrument Serif', serif;
      font-size: 20px;
      color: var(--ink);
      text-decoration: none;
    }
    .nav-logo span { color: var(--accent); }

    .nav-badge {
      background: var(--accent-light);
      color: var(--accent);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.06em;
      padding: 3px 10px;
      border-radius: 999px;
      text-transform: uppercase;
    }

    .nav-right {
      display: flex; align-items: center; gap: 12px;
    }

    .nav-link-sm {
      font-size: 13px;
      color: var(--ink-3);
      text-decoration: none;
      font-weight: 500;
      transition: color 0.2s;
    }
    .nav-link-sm:hover { color: var(--accent); }

    /* ‚îÄ‚îÄ MAIN LAYOUT ‚îÄ‚îÄ */
    .app-shell {
      flex: 1;
      display: flex;
      max-width: 1280px;
      width: 100%;
      margin: 0 auto;
      padding: 24px 32px;
      gap: 24px;
    }

    /* ‚îÄ‚îÄ SIDEBAR ‚îÄ‚îÄ */
    .sidebar {
      width: var(--sidebar);
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sidebar-section-label {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--ink-3);
      padding: 4px 8px;
      margin-top: 8px;
    }

    .sidebar-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.15s;
      font-size: 14px;
      font-weight: 500;
      color: var(--ink-2);
      border: 1px solid transparent;
      background: none;
      width: 100%;
      text-align: left;
    }
    .sidebar-item:hover {
      background: white;
      border-color: var(--border);
    }
    .sidebar-item.active {
      background: white;
      border-color: rgba(201,106,46,0.2);
      color: var(--accent);
    }

    .sidebar-icon {
      width: 28px; height: 28px;
      border-radius: 8px;
      background: var(--paper-2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }
    .sidebar-item.active .sidebar-icon {
      background: var(--accent-light);
    }

    .sidebar-divider {
      border: none;
      border-top: 1px solid var(--border);
      margin: 8px 0;
    }

    /* ‚îÄ‚îÄ CONTENT AREA ‚îÄ‚îÄ */
    .content-area {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* ‚îÄ‚îÄ RENDER PANEL (right) ‚îÄ‚îÄ */
    .render-panel {
      width: 420px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* ‚îÄ‚îÄ CARDS ‚îÄ‚îÄ */
    .card {
      background: white;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 24px;
    }

    .card-title {
      font-family: 'Instrument Serif', serif;
      font-size: 17px;
      color: var(--ink);
      margin-bottom: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .card-title-icon {
      font-size: 16px;
    }

    /* ‚îÄ‚îÄ FORM ELEMENTS ‚îÄ‚îÄ */
    label.field-label {
      display: block;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--ink-3);
      margin-bottom: 6px;
    }

    textarea, input[type="text"], select {
      width: 100%;
      background: var(--paper);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px 14px;
      font-family: 'DM Sans', sans-serif;
      font-size: 14px;
      color: var(--ink);
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    textarea:focus, input[type="text"]:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(201,106,46,0.1);
    }
    textarea { min-height: 80px; resize: vertical; }
    select { cursor: pointer; }

    input[type="file"] {
      font-family: 'DM Sans', sans-serif;
      font-size: 13px;
      color: var(--ink-3);
    }

    /* ‚îÄ‚îÄ BUTTONS ‚îÄ‚îÄ */
    .btn {
      font-family: 'DM Sans', sans-serif;
      font-size: 14px;
      font-weight: 600;
      padding: 9px 18px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }
    .btn:disabled { opacity: 0.45; cursor: default; }

    .btn-primary {
      background: var(--accent);
      color: white;
    }
    .btn-primary:not(:disabled):hover {
      background: var(--accent-2);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(201,106,46,0.3);
    }

    .btn-secondary {
      background: white;
      color: var(--ink-2);
      border: 1px solid var(--border);
    }
    .btn-secondary:not(:disabled):hover {
      background: var(--paper-2);
    }

    .btn-danger {
      background: white;
      color: #c0392b;
      border: 1px solid rgba(192,57,43,0.2);
    }
    .btn-danger:hover { background: #fdf0ee; }

    .btn-translate {
      width: 100%;
      padding: 13px 20px;
      font-size: 15px;
      border-radius: var(--radius);
      background: var(--accent);
      color: white;
      border: none;
      font-family: 'DM Sans', sans-serif;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-translate:not(:disabled):hover {
      background: var(--accent-2);
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(201,106,46,0.3);
    }
    .btn-translate:disabled { opacity: 0.5; cursor: default; }

    /* ‚îÄ‚îÄ ROW LAYOUT ‚îÄ‚îÄ */
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .grow { flex: 1 1 auto; min-width: 0; }

    /* ‚îÄ‚îÄ STATUS INDICATOR ‚îÄ‚îÄ */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      font-weight: 500;
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--paper-2);
      color: var(--ink-3);
    }
    .status-badge.ready {
      background: var(--green-light);
      color: var(--green);
    }
    .status-badge.loading {
      background: var(--accent-light);
      color: var(--accent);
    }
    .status-badge::before {
      content: '';
      width: 6px; height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    /* ‚îÄ‚îÄ LOG ‚îÄ‚îÄ */
    .log-area {
      background: var(--paper);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
      font-family: ui-monospace, 'Menlo', monospace;
      font-size: 12px;
      line-height: 1.6;
      color: var(--ink-3);
      min-height: 48px;
      max-height: 180px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    /* ‚îÄ‚îÄ AVATAR AREA ‚îÄ‚îÄ */
    .avatar-wrapper {
      background: var(--paper);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    .avatar-stage {
      background: white;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .CWASAAvatar.av0 { width: 384px; height: 320px; }

    .avatar-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }

    /* ‚îÄ‚îÄ TABS for input mode ‚îÄ‚îÄ */
    .input-tabs {
      display: flex;
      gap: 4px;
      background: var(--paper-2);
      padding: 4px;
      border-radius: var(--radius-sm);
      margin-bottom: 16px;
    }
    .input-tab {
      flex: 1;
      padding: 8px;
      font-family: 'DM Sans', sans-serif;
      font-size: 13px;
      font-weight: 500;
      color: var(--ink-3);
      background: none;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .input-tab.active {
      background: white;
      color: var(--accent);
      box-shadow: 0 1px 4px rgba(26,22,18,0.08);
    }

    /* Tab panels */
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }

    /* ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ */
    .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .chip {
      background: var(--paper);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 5px 12px;
      font-size: 12px;
      font-weight: 500;
      color: var(--ink-2);
    }

    /* ‚îÄ‚îÄ HINT TEXT ‚îÄ‚îÄ */
    .hint {
      font-size: 12px;
      color: var(--ink-3);
      line-height: 1.5;
      margin-top: 6px;
    }

    /* ‚îÄ‚îÄ SECTION PANELS (sidebar driven) ‚îÄ‚îÄ */
    .content-panel { display: none; }
    .content-panel.active { display: flex; flex-direction: column; gap: 16px; }

    /* ‚îÄ‚îÄ ADVANCED PANEL ‚îÄ‚îÄ */
    .advanced-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }

    /* ‚îÄ‚îÄ CHECKBOX LABEL ‚îÄ‚îÄ */
    .check-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 500;
      color: var(--ink-2);
      cursor: pointer;
    }
    .check-label input[type="checkbox"] {
      width: auto;
      accent-color: var(--accent);
    }

    /* ‚îÄ‚îÄ MAIN 3-COLUMN LAYOUT ‚îÄ‚îÄ */
    @media (min-width: 1100px) {
      .app-shell {
        flex-direction: row;
      }
    }

    /* ‚îÄ‚îÄ MOBILE ‚îÄ‚îÄ */
    @media (max-width: 1099px) {
      .app-shell { flex-direction: column; padding: 16px; }
      .sidebar { width: 100%; flex-direction: row; flex-wrap: wrap; gap: 4px; }
      .sidebar-section-label { display: none; }
      .sidebar-divider { display: none; }
      .render-panel { width: 100%; }
      .CWASAAvatar.av0 { width: 100%; height: auto; }
      .advanced-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

  <!-- NAV -->
  <nav class="app-nav">
    <div style="display:flex; align-items:center; gap:12px;">
      <a href="index.html" class="nav-logo">Bridg<span>n</span></a>
      <span class="nav-badge">Translator</span>
    </div>
    <div class="nav-right">
      <a href="contribute.html" class="nav-link-sm">Contribute</a>
      <a href="index.html" class="nav-link-sm">‚Üê Home</a>
    </div>
  </nav>

  <!-- APP SHELL -->
  <div class="app-shell">

    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="sidebar-section-label">Input</div>

      <button class="sidebar-item active" data-panel="translate" onclick="switchPanel('translate', this)">
        <div class="sidebar-icon">ü§ü</div>
        Translate
      </button>

      <button class="sidebar-item" data-panel="microphone" onclick="switchPanel('microphone', this)">
        <div class="sidebar-icon">üéôÔ∏è</div>
        Microphone
      </button>

      <button class="sidebar-item" data-panel="video" onclick="switchPanel('video', this)">
        <div class="sidebar-icon">üé¨</div>
        Video Upload
      </button>

      <hr class="sidebar-divider" />
      <div class="sidebar-section-label">Configuration</div>

      <button class="sidebar-item" data-panel="database" onclick="switchPanel('database', this)">
        <div class="sidebar-icon">üóÑÔ∏è</div>
        Database
      </button>

      <button class="sidebar-item" data-panel="advanced" onclick="switchPanel('advanced', this)">
        <div class="sidebar-icon">‚öôÔ∏è</div>
        Advanced
      </button>

      <hr class="sidebar-divider" />
      <div class="sidebar-section-label">Debug</div>

      <button class="sidebar-item" data-panel="planner" onclick="switchPanel('planner', this)">
        <div class="sidebar-icon">üìã</div>
        Planner Log
      </button>
    </aside>

    <!-- MAIN CONTENT -->
    <div class="content-area">

      <!-- PANEL: TRANSLATE -->
      <div class="content-panel active" id="panel-translate">
        <div class="card">
          <div class="card-title"><span class="card-title-icon">‚úèÔ∏è</span> Text Input</div>
          <label class="field-label">Enter your phrase</label>
          <textarea id="textIn" placeholder="Type a phrase to translate into sign language‚Ä¶" rows="3"></textarea>

          <div class="row" style="margin-top: 12px;">
            <div class="grow">
              <label class="field-label" style="margin-bottom:6px;">Language hint (for speech)</label>
              <select id="langHint">
                <option value="auto">auto-detect</option>
                <option value="en" selected>English</option>
                <option value="ru">Russian</option>
                <option value="es">Spanish</option>
                <option value="de">German</option>
                <option value="fr">French</option>
                <option value="zh">Chinese</option>
                <option value="ja">Japanese</option>
              </select>
            </div>
          </div>

          <button id="translateBtn" class="btn-translate" style="margin-top: 16px;">
            ü§ü Translate to Sign
          </button>
        </div>
      </div>

      <!-- PANEL: MICROPHONE -->
      <div class="content-panel" id="panel-microphone">
        <div class="card">
          <div class="card-title"><span class="card-title-icon">üéôÔ∏è</span> Microphone Input</div>
          <div class="row" style="margin-bottom:12px;">
            <button id="recordBtn" class="btn btn-secondary">‚óè Start recording</button>
            <button id="transcribeBtn" class="btn btn-primary">Transcribe</button>
            <span id="micStatus" class="status-badge">Idle</span>
          </div>
          <label class="field-label">Transcription</label>
          <textarea id="transcription" placeholder="Transcription will appear here‚Ä¶"></textarea>
          <p class="hint">üîí On-device Whisper (transformers.js). First run downloads the model (~100‚Äì200MB). No audio leaves your device.</p>
        </div>
      </div>

      <!-- PANEL: VIDEO -->
      <div class="content-panel" id="panel-video">
        <div class="card">
          <div class="card-title"><span class="card-title-icon">üé¨</span> Video Upload ‚Üí Sign</div>
          <label class="field-label">Select video file</label>
          <input type="file" id="videoFile" accept="video/*" style="margin-bottom:12px;" />
          <div class="row">
            <button id="videoToSignBtn" class="btn btn-primary">Process Video ‚Üí Sign</button>
            <span id="videoStatus" class="status-badge">No file selected</span>
          </div>
          <p class="hint" style="margin-top:12px;">Extracts audio via ffmpeg, transcribes with Whisper, then plans and renders sign animation.</p>
        </div>
      </div>

      <!-- PANEL: DATABASE -->
      <div class="content-panel" id="panel-database">
        <div class="card">
          <div class="card-title"><span class="card-title-icon">üóÑÔ∏è</span> Sign Database</div>

          <label class="field-label">SiGML database URL</label>
          <div class="row" style="margin-bottom:14px;">
            <input id="dbUrlInput" type="text" placeholder="/data/hamnosys_bsl_version1.sigml" class="grow" />
            <button id="loadDbBtn" class="btn btn-primary">Load</button>
          </div>
          <p class="hint" style="margin-bottom:14px;">Load multiple files one-by-one. Later entries override earlier duplicates by gloss.</p>

          <label class="field-label">Concept map CSV (URL)</label>
          <div class="row" style="margin-bottom:8px;">
            <input id="conceptUrlInput" type="text" placeholder="/data/hamnosys_bsl.csv" class="grow" />
            <button id="loadConceptBtn" class="btn btn-primary">Load</button>
          </div>

          <label class="field-label" style="margin-top:12px;">Or upload CSV / TSV file</label>
          <input id="conceptFile" type="file" accept=".csv,.tsv,text/csv,text/tab-separated-values" />

          <div style="margin-top:16px; padding-top:14px; border-top:1px solid var(--border);">
            <label class="field-label">OpenAI API key (optional)</label>
            <div class="row">
              <input id="openaiKey" type="text" placeholder="sk-‚Ä¶" class="grow" />
              <button id="saveKeyBtn" class="btn btn-secondary">Save locally</button>
            </div>
            <p class="hint">Stored in localStorage only. Used as an optional GPT-4o-mini planner fallback.</p>
          </div>
        </div>

        <div class="card">
          <div class="card-title"><span class="card-title-icon">üìö</span> Loaded Vocabulary</div>
          <div id="allowedOut" style="font-family: ui-monospace, monospace; font-size:12px; color:var(--ink-3); max-height:160px; overflow:auto; line-height:1.8;"></div>
        </div>
      </div>

      <!-- PANEL: ADVANCED -->
      <div class="content-panel" id="panel-advanced">
        <div class="card">
          <div class="card-title"><span class="card-title-icon">‚öôÔ∏è</span> EDU NLP Pipeline</div>

          <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:16px;">
            <label class="check-label"><input type="checkbox" id="eduNlpToggle" /> Use EDU NLP pipeline</label>
            <label class="check-label"><input type="checkbox" id="applyAbbrev" /> Apply abbreviations</label>
            <label class="check-label"><input type="checkbox" id="stemMode" /> STEM mode (preload STEM abbreviations)</label>
          </div>

          <label class="field-label">Load abbreviations JSON (URL)</label>
          <div class="row" style="margin-bottom:10px;">
            <input id="abbrevUrl" type="text" placeholder="abbreviations.json" class="grow" />
            <button id="loadAbbrevUrlBtn" class="btn btn-primary">Load</button>
          </div>

          <label class="field-label">Or upload abbreviations JSON file</label>
          <div class="row">
            <input id="abbrevFile" type="file" accept="application/json" class="grow" />
            <button id="clearAbbrevBtn" class="btn btn-danger">Clear</button>
          </div>

          <p class="hint" style="margin-top:10px;">EDU NLP extracts pronouns, verb lemmas, and key nouns. Abbreviations collapse multi-word forms (e.g., "carbon dioxide" ‚Üí "CO‚ÇÇ").</p>
        </div>
      </div>

      <!-- PANEL: PLANNER -->
      <div class="content-panel" id="panel-planner">
        <div class="card">
          <div class="card-title"><span class="card-title-icon">üìã</span> Planner Diagnostics</div>

          <label class="field-label">Planner log</label>
          <div id="planLog" class="log-area" style="margin-bottom:14px;"></div>

          <div class="advanced-grid">
            <div>
              <label class="field-label">Normalized input</label>
              <input type="text" id="normalizedOut" readonly />
            </div>
            <div>
              <label class="field-label">Token sequence</label>
              <input type="text" id="tokensOut" readonly />
            </div>
            <div>
              <label class="field-label">Timeframe guess</label>
              <input type="text" id="timeframeOut" readonly />
            </div>
            <div>
              <label class="field-label">Abbreviations applied</label>
              <input type="text" id="abbrevCountOut" readonly />
            </div>
          </div>
        </div>
      </div>

    </div><!-- /content-area -->

    <!-- RENDER PANEL -->
    <div class="render-panel">
      <div class="avatar-wrapper">
        <div class="avatar-stage">
          <div class="CWASAAvatar av0"></div>
        </div>
        <div class="avatar-controls">
          <span id="renderStatus" class="status-badge loading">CWASA loading‚Ä¶</span>
          <button id="stopBtn" class="btn btn-secondary">‚èπ Stop</button>
        </div>
        <div style="width:100%; font-size:12px; color:var(--ink-3); line-height:1.5; padding-top:4px; border-top:1px solid var(--border);">
          Sign animations rendered via <strong>CWASA</strong> using SiGML + HamNoSys gloss sequences. Unmatched words are fingerspelled when the alphabet database is loaded.
        </div>
      </div>
    </div>

  </div><!-- /app-shell -->

  <!-- ===== ALL ORIGINAL SCRIPTS (fully preserved) ===== -->

  <script>
  const renderStatus = document.getElementById('renderStatus');

  function initCWASA() {
    if (!window.CWASA) {
      renderStatus.textContent = 'CWASA script not loaded.';
      renderStatus.className = 'status-badge';
      return;
    }
    CWASA.init({
      useClientConfig: false,
      useCwaConfig: true,
      avSettings: [{
        width: 384,
        height: 320,
        avList: 'avs',
        initAv: 'luna',
        ambIdle: true,
        allowFrameSteps: false,
        allowSiGMLText: false,
      }]
    });
    if (CWASA.ready && typeof CWASA.ready.then === 'function') {
      CWASA.ready.then(() => {
        renderStatus.textContent = 'Ready';
        renderStatus.className = 'status-badge ready';
      });
    } else {
      setTimeout(() => {
        renderStatus.textContent = 'Ready';
        renderStatus.className = 'status-badge ready';
      }, 300);
    }
  }
  window.addEventListener('load', () => {
    setTimeout(() => {
      try { initCWASA(); } catch (e) {
        console.error(e);
        renderStatus.textContent = 'CWASA init error ‚Äî see console.';
      }
    }, 150);
  });
  </script>

  <script>
    // ‚îÄ‚îÄ SIDEBAR PANEL SWITCHER ‚îÄ‚îÄ
    function switchPanel(name, btn) {
      document.querySelectorAll('.content-panel').forEach(p => p.classList.remove('active'));
      document.querySelectorAll('.sidebar-item').forEach(b => b.classList.remove('active'));
      document.getElementById('panel-' + name).classList.add('active');
      btn.classList.add('active');
    }
  </script>

  <script>
    const abbrevUrl = document.getElementById('abbrevUrl');
    const loadAbbrevUrlBtn = document.getElementById('loadAbbrevUrlBtn');
    const abbrevFile = document.getElementById('abbrevFile');
    const clearAbbrevBtn = document.getElementById('clearAbbrevBtn');
    const applyAbbrev = document.getElementById('applyAbbrev');
    const eduNlpToggle = document.getElementById('eduNlpToggle');
    const stemMode = document.getElementById('stemMode');
    const timeframeOut = document.getElementById('timeframeOut');
    const abbrevCountOut = document.getElementById('abbrevCountOut');

    let ABBREV = new Map();

    const STEM_PRESET = {
      'carbon dioxide': 'co2', 'deoxyribonucleic acid': 'dna',
      'adenosine triphosphate': 'atp', 'machine learning': 'ml',
      'artificial intelligence': 'ai', 'central processing unit': 'cpu',
      'graphics processing unit': 'gpu',
    };

    function applyStemPreset(){ for (const [k,v] of Object.entries(STEM_PRESET)) ABBREV.set(k.toLowerCase(), v.toLowerCase()); }
    function clearAbbrev(){ ABBREV.clear(); updateAbbrevCount(0); log('Cleared abbreviations.'); }
    function updateAbbrevCount(n){ if(abbrevCountOut) abbrevCountOut.value = String(n); }

    async function loadAbbrevFromUrl(url){
      try{
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const obj = await res.json();
        let n = 0;
        for (const [k,v] of Object.entries(obj||{})){ ABBREV.set(String(k).toLowerCase().trim(), String(v).toLowerCase().trim()); n++; }
        updateAbbrevCount(ABBREV.size); log(`Loaded ${n} abbreviations from ${url}`);
      }catch(e){ log('Abbrev load error: ' + e); }
    }

    async function loadAbbrevFromFile(file){
      try{
        const txt = await file.text();
        const obj = JSON.parse(txt);
        let n = 0;
        for (const [k,v] of Object.entries(obj||{})){ ABBREV.set(String(k).toLowerCase().trim(), String(v).toLowerCase().trim()); n++; }
        updateAbbrevCount(ABBREV.size); log(`Loaded ${n} abbreviations from file: ${file.name}`);
      }catch(e){ log('Abbrev file error: ' + e); }
    }

    function replaceAbbreviationsBrowser(text){
      if (!applyAbbrev.checked || ABBREV.size === 0) return { text, count: 0 };
      const pairs = Array.from(ABBREV.entries()).sort((a,b)=> b[0].length - a[0].length);
      let count = 0; let out = text;
      for (const [phrase, replRaw] of pairs){
        const escaped = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = new RegExp('(^|[^A-Za-z0-9_])(' + escaped + ')(?=[^A-Za-z0-9_]|$)', 'gi');
        out = out.replace(re, (match, pre, matched) => {
          count++;
          const raw = String(replRaw);
          const repl = (/^[a-z]{2,5}$/i.test(raw) && /^[a-z]{2,5}$/.test(raw)) ? raw.toUpperCase() : raw;
          return pre + repl;
        });
      }
      return { text: out, count };
    }

    const EDU_STOPWORDS = new Set(['a','an','the','and','or','but','if','then','than','of','to','in','on','at','for','from','with','as','by','is','are','am','be','been','was','were','do','does','did','that','this','those','these','it','my','your','our']);

    function timeframeGuess(str){
      const s = (str || '').toLowerCase();
      if (/\bwill\b|\btomorrow\b|\bnext\b/.test(s)) return 'Future';
      if (/\byesterday\b|\bago\b|\blast\b/.test(s)) return 'Past';
      return 'Present';
    }

    function processEducationalText(text){
      const doc = window.nlp(text);
      const tokens = [];
      const pronouns = doc.match('#Pronoun').out('array').map(s=>s.toLowerCase());
      for (const p of pronouns){ if (!EDU_STOPWORDS.has(p)) tokens.push(p); }
      const verbInf = doc.verbs().toInfinitive().out('array').map(s=>s.toLowerCase());
      for (const v of verbInf){ if (!EDU_STOPWORDS.has(v)) tokens.push(v); }
      const nouns = doc.nouns().toSingular().out('array').map(s=>s.toLowerCase());
      for (const n of nouns){ if (!EDU_STOPWORDS.has(n)) tokens.push(n); }
      const seen = new Set();
      return tokens.filter(t=>{ if (seen.has(t)) return false; seen.add(t); return true; });
    }

    loadAbbrevUrlBtn.addEventListener('click', ()=>{ const u = abbrevUrl.value.trim(); if (u) loadAbbrevFromUrl(u); });
    if (abbrevFile) abbrevFile.addEventListener('change', (e) => { const f = e.target?.files?.[0]; if (f) loadAbbrevFromFile(f); });
    clearAbbrevBtn.addEventListener('click', ()=> clearAbbrev());
    stemMode.addEventListener('change', ()=>{ if (stemMode.checked){ applyStemPreset(); updateAbbrevCount(ABBREV.size); log('STEM preset loaded.'); } });
  </script>

  <script>
    const allowedOut = document.getElementById('allowedOut');
    const dbUrlInput = document.getElementById('dbUrlInput');
    const loadDbBtn = document.getElementById('loadDbBtn');
    const conceptUrlInput = document.getElementById('conceptUrlInput');
    const loadConceptBtn  = document.getElementById('loadConceptBtn');
    const conceptFile     = document.getElementById('conceptFile');

    const glossToSign = new Map();
    const letterToSign = new Map();
    const baseToGloss = new Map();
    const conceptToGloss = new Map();

    function glossBase(gloss) {
      return String(gloss).toLowerCase().replace(/\(.*?\)/g,'').replace(/#\d+$/g,'').replace(/[^a-z0-9]+/g,' ').trim();
    }

    function rebuildBaseIndex() {
      baseToGloss.clear();
      for (const g of glossToSign.keys()){ const b = glossBase(g); if (!baseToGloss.has(b)) baseToGloss.set(b, g); }
    }

    async function loadSigmlUrl(url, isAutoload = false){
      try{
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok){ if (isAutoload && res.status === 404){ log(`Optional DB missing: ${url}`); return; } throw new Error('HTTP ' + res.status); }
        const xmlText = await res.text();
        const doc = new DOMParser().parseFromString(xmlText, 'application/xml');
        const signs = Array.from(doc.querySelectorAll('hns_sign'));
        let added = 0;
        for (const s of signs){ const gloss = (s.getAttribute('gloss')||'').trim().toLowerCase(); if (!gloss) continue; glossToSign.set(gloss, s.outerHTML); added++; }
        refreshAllowedOutput(); log(`Loaded ${added} signs from ${url}`);
      }catch(e){ if (isAutoload){ log(`Optional DB missing: ${url}`); } else { log(`Failed to load ${url}: ${e}.`); } }
    }

    function refreshAllowedOutput(){
      const list = Array.from(glossToSign.keys()).sort();
      if (allowedOut) allowedOut.textContent = list.join(', ');
      rebuildBaseIndex();
    }

    async function loadAlphabetSigmlUrl(url, isAutoload = false){
      try{
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok){ if (isAutoload && res.status === 404){ log(`Optional alphabet DB missing: ${url}`); return; } throw new Error('HTTP ' + res.status); }
        const xmlText = await res.text();
        const doc = new DOMParser().parseFromString('<root>' + xmlText + '</root>', 'application/xml');
        const signs = Array.from(doc.querySelectorAll('hns_sign'));
        let added = 0;
        for (const s of signs){ const gloss = (s.getAttribute('gloss')||'').trim().toUpperCase(); if (!gloss || gloss.length !== 1 || gloss < 'A' || gloss > 'Z') continue; letterToSign.set(gloss, s.outerHTML); added++; }
        log(`Loaded ${added} alphabet letters from ${url}`);
      }catch(e){ if (isAutoload){ log(`Optional alphabet DB missing: ${url}`); } else { log(`Failed to load alphabet ${url}: ${e}.`); } }
    }

    function parseTable(text){
      let cleaned = text;
      if (text.charCodeAt(0) === 0xFEFF) cleaned = text.slice(1);
      const delim = cleaned.includes('\t') ? '\t' : ',';
      const lines = cleaned.split(/\r?\n/).filter(line => line.trim());
      if (!lines.length) return { header: [], rows: [] };
      const header = (lines.shift()||'').split(delim).map(s=>s.trim().toLowerCase());
      const rows = lines.map(line => { const cols = line.split(delim).map(s=>s.trim()); const obj = {}; for (let i=0;i<header.length;i++) obj[header[i]] = cols[i]||''; return obj; });
      return { header, rows };
    }

    async function loadConceptCsvUrl(url, isAutoload = false){
      try{
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok){ if (isAutoload && res.status === 404){ log(`Optional DB missing: ${url}`); return; } throw new Error('HTTP ' + res.status); }
        const txt = await res.text();
        const { header, rows } = parseTable(txt);
        if (!header.includes('concept') || !header.includes('gloss')) throw new Error('CSV must have "concept" and "gloss" headers');
        let n = 0;
        for (const r of rows){ const concept = String(r.concept||'').toLowerCase().trim(); const gloss = String(r.gloss||'').toLowerCase().trim(); if (!concept||!gloss) continue; conceptToGloss.set(glossBase(concept), gloss); n++; }
        log(`Loaded ${n} concepts from ${url}`);
      }catch(e){ if (isAutoload){ log(`Optional DB missing: ${url}`); } else { log('Concept CSV load error: ' + e); } }
    }

    async function loadConceptCsvFile(file){
      try{
        const txt = await file.text();
        const { header, rows } = parseTable(txt);
        if (!header.includes('concept') || !header.includes('gloss')) throw new Error('CSV must have "concept" and "gloss" headers');
        let n = 0;
        for (const r of rows){ const concept = String(r.concept||'').toLowerCase().trim(); const gloss = String(r.gloss||'').toLowerCase().trim(); if (!concept||!gloss) continue; conceptToGloss.set(glossBase(concept), gloss); n++; }
        log(`Loaded ${n} concept‚Üígloss entries from file: ${file.name}`);
      }catch(e){ log('Concept CSV file error: ' + e); }
    }

    loadConceptBtn?.addEventListener('click', ()=>{ const u = conceptUrlInput?.value.trim(); if (u) loadConceptCsvUrl(u); });
    if (conceptFile) conceptFile.addEventListener('change', (e) => { const f = e.target?.files?.[0]; if (f) loadConceptCsvFile(f); });
    loadDbBtn?.addEventListener('click', () => { const u = dbUrlInput.value.trim(); if (u) loadSigmlUrl(u); });

    window.addEventListener('load', async () => {
      await loadSigmlUrl('/data/hamnosys_bsl_version1.sigml', true);
      await loadConceptCsvUrl('/data/hamnosys_bsl.csv', true);
      await loadAlphabetSigmlUrl('/data/bsl_alphabet_sigml.sigml', true);
    });
  </script>

  <script>
    const textIn = document.getElementById('textIn');
    const planLog = document.getElementById('planLog');
    const normalizedOut = document.getElementById('normalizedOut');
    const tokensOut = document.getElementById('tokensOut');

    async function planWithSpaCyBackend(rawText) {
      try {
        const resp = await fetch('/api/plan', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: rawText }) });
        if (!resp.ok) { const detail = await resp.text().catch(() => ''); throw new Error(`Backend HTTP ${resp.status} ${detail}`); }
        return await resp.json();
      } catch (e) { console.error("spaCy backend fetch failed:", e); throw e; }
    }

    const STOPWORDS = new Set(['a','an','the','and','or','but','if','then','than','of','to','in','on','at','for','from','with','as','by','is','are','am','be','been','was','were','do','does','did','that','this','those','these','it','my','your','our']);
    const TOPIC_TIME = new Set(['today','yesterday','tomorrow','morning','afternoon','evening','night','noon','week','month','year','time']);

    function normalizeText(str){
      try { return (str||'').toLowerCase().replace(/[\p{P}\p{S}]/gu,' ').split(/\s+/).filter(Boolean); }
      catch(e) { return (str||'').toLowerCase().replace(/[^\w\s]/g,' ').split(/\s+/).filter(Boolean); }
    }

    function heuristicPlan(tokens){ const kept = tokens.filter(t => !STOPWORDS.has(t)); const front = kept.filter(t => TOPIC_TIME.has(t)); const rest = kept.filter(t => !TOPIC_TIME.has(t)); return [...front, ...rest]; }

    function levenshtein(a,b){ const m=a.length, n=b.length; if(!m) return n; if(!n) return m; const dp = new Array(n+1); for(let j=0;j<=n;j++) dp[j]=j; for(let i=1;i<=m;i++){ let prev = dp[0]; dp[0]=i; for(let j=1;j<=n;j++){ const temp = dp[j]; dp[j] = Math.min(dp[j]+1, dp[j-1]+1, prev+(a[i-1]===b[j-1]?0:1)); prev = temp; } } return dp[n]; }
    function similarity(a,b){ if (!a||!b) return 0; const d = levenshtein(a,b); return 1 - d / Math.max(a.length, b.length); }

    function mapToAvailable(tokens, allowedGlosses, cutoff = 0.82){
      const mapped = [], subs = {}, missing = [], fingerspelled = [];
      if (!allowedGlosses.length) return { mapped, subs, missing: [...tokens], fingerspelled };
      const bases = allowedGlosses.map(g => glossBase(g));
      const baseToGlossLocal = new Map();
      for (let i=0; i<allowedGlosses.length; i++){ const g = allowedGlosses[i]; const b = bases[i]; if (!baseToGlossLocal.has(b)) baseToGlossLocal.set(b, g); }
      for (const t of tokens){
        if (allowedGlosses.includes(t)) { mapped.push(t); continue; }
        const tBase = glossBase(t);
        if (conceptToGloss.has(tBase)) { const g = conceptToGloss.get(tBase); mapped.push(g); if (t !== g) subs[t] = g; continue; }
        if (baseToGloss.has(tBase)) { const g = baseToGloss.get(tBase); mapped.push(g); if (t !== g) subs[t] = g; continue; }
        if (baseToGlossLocal.has(tBase)) { const g = baseToGlossLocal.get(tBase); mapped.push(g); if (t !== tBase) subs[t] = g; continue; }
        let bestBase = null, bestScore = 0;
        for (const b of baseToGlossLocal.keys()){ const s = similarity(tBase, b); if (s > bestScore) { bestScore = s; bestBase = b; } }
        if (bestBase && bestScore >= cutoff){ const g = baseToGlossLocal.get(bestBase); mapped.push(g); subs[t] = g; }
        else { if (letterToSign.size > 0 && /[A-Za-z]/.test(t)){ mapped.push(t); fingerspelled.push(t); } else { missing.push(t); } }
      }
      return { mapped, subs, missing, fingerspelled };
    }

    function currentAllowed(){ return Array.from(glossToSign.keys()).sort(); }

    async function planWithOpenAI(rawText, allowed){
      const key = localStorage.getItem('openai_key');
      if (!key) return null;
      const system = "You rewrite user sentences into ASL-friendly word order as tokens. Use ONLY words from the allowed vocabulary provided. Return ONLY the final token sequence as a single space-separated line.";
      const user = `ALLOWED:\n${allowed.join(', ')}\n\nTEXT:\n${rawText}\n\nFORMAT:\nspace-separated tokens, lowercase`;
      try{
        const resp = await fetch('https://api.openai.com/v1/chat/completions',{ method:'POST', headers:{ 'Authorization': `Bearer ${key}`, 'Content-Type':'application/json' }, body: JSON.stringify({ model:'gpt-4o-mini', temperature:0.1, messages:[{role:'system',content:system},{role:'user',content:user}] }) });
        if (!resp.ok) throw new Error('OpenAI HTTP ' + resp.status);
        const data = await resp.json();
        let content = data?.choices?.[0]?.message?.content?.trim() || '';
        const toks = content.split(/\s+/).filter(w => allowed.includes(w));
        return toks.length ? toks : null;
      }catch(e){ log('OpenAI planner error: ' + e); return null; }
    }

    async function doPlan(mode) {
      const raw0 = textIn.value.trim();
      if (!raw0) { log('Empty text.'); return; }
      const allowed = currentAllowed();
      if (allowed.length === 0) { log('No sign database loaded yet.'); return; }
      const { text: raw, count: abCount } = replaceAbbreviationsBrowser(raw0);
      if (abbrevCountOut) abbrevCountOut.value = String(abCount);
      if (timeframeOut) timeframeOut.value = timeframeGuess(raw);
      let mapped = null, subs = {}, missing = [];
      const rawTokens = raw.split(/\s+/).map(s => s.toLowerCase()).filter(Boolean);
      if (rawTokens.length && rawTokens.every(t => allowed.includes(t))) {
        if (normalizedOut) normalizedOut.value = rawTokens.join(' ');
        if (planLog) planLog.textContent = 'planned (exact gloss)';
        if (tokensOut) tokensOut.value = rawTokens.join(' ');
        window.__plannedTokens = rawTokens; return;
      }
      const phraseBase = glossBase(raw);
      if (conceptToGloss.has(phraseBase)) {
        const g = conceptToGloss.get(phraseBase);
        mapped = [g];
        if (normalizedOut) normalizedOut.value = raw;
        if (planLog) planLog.textContent = `concept-map: "${raw}" ‚Üí "${g}"`;
        if (tokensOut) tokensOut.value = g;
        window.__plannedTokens = mapped; return;
      }
      if (mode === 'spacy') {
        try {
          const backend = await planWithSpaCyBackend(raw);
          if (backend.error) { log('Backend error: ' + backend.error); throw new Error(backend.error); }
          const backendTokens = String(backend.final||'').replace(/[.\n]/g,' ').split(/\s+/).filter(Boolean);
          const m = mapToAvailable(backendTokens, allowed, 0.82);
          const displayTokens = m.mapped.length ? m.mapped : backendTokens;
          if (normalizedOut) normalizedOut.value = backendTokens.join(' ');
          if (planLog){ const lines = ['spacy-backend']; if (Object.keys(m.subs).length) lines.push('subs: '+JSON.stringify(m.subs)); if (m.fingerspelled?.length) lines.push('fingerspelled: '+m.fingerspelled.join(', ')); if (m.missing.length) lines.push('missing: '+m.missing.join(', ')); planLog.textContent = lines.join('\n'); }
          if (tokensOut) tokensOut.value = displayTokens.join(' ');
          window.__plannedTokens = displayTokens; return;
        } catch (e) { log('Python backend error, falling back: ' + e); }
      }
      else if (mode === 'openai') {
        try {
          const openTokens = await planWithOpenAI(raw, allowed);
          if (openTokens?.length) {
            const m = mapToAvailable(openTokens, allowed, 0.82);
            mapped = m.mapped; subs = m.subs; missing = m.missing;
            if (normalizedOut) normalizedOut.value = openTokens.join(' ');
            if (planLog){ const lines = ['openai-backend']; if (Object.keys(subs).length) lines.push('subs: '+JSON.stringify(subs)); if (m.fingerspelled?.length) lines.push('fingerspelled: '+m.fingerspelled.join(', ')); if (missing.length) lines.push('missing: '+missing.join(', ')); planLog.textContent = lines.join('\n'); }
          }
        } catch (e) { log('OpenAI error, falling back: ' + e); }
      }
      if (!mapped?.length && eduNlpToggle.checked) {
        const eduTokens = processEducationalText(raw);
        const mEdu = mapToAvailable(eduTokens, allowed, 0.82);
        mapped = mEdu.mapped; subs = mEdu.subs; missing = mEdu.missing;
        if (normalizedOut) normalizedOut.value = eduTokens.join(' ');
        if (planLog){ const lines = ['edu-nlp']; if (Object.keys(subs).length) lines.push('subs: '+JSON.stringify(subs)); if (mEdu.fingerspelled?.length) lines.push('fingerspelled: '+mEdu.fingerspelled.join(', ')); if (missing.length) lines.push('missing: '+missing.join(', ')); planLog.textContent = lines.join('\n'); }
      }
      if (!mapped?.length) {
        const norm = normalizeText(raw);
        const heur = heuristicPlan(norm);
        const mHeur = mapToAvailable(heur, allowed, 0.82);
        mapped = mHeur.mapped; subs = mHeur.subs; missing = mHeur.missing;
        if (normalizedOut) normalizedOut.value = norm.join(' ');
        if (planLog){ const lines = []; if (heur.length) lines.push('heuristic: '+heur.join(' ')); if (Object.keys(subs).length) lines.push('subs: '+JSON.stringify(subs)); if (mHeur.fingerspelled?.length) lines.push('fingerspelled: '+mHeur.fingerspelled.join(', ')); if (missing.length) lines.push('missing: '+missing.join(', ')); planLog.textContent = lines.length ? lines.join('\n') : 'planned'; }
      }
      if (!mapped?.length) { log('No tokens mapped to available signs.'); return; }
      if (tokensOut) tokensOut.value = mapped.join(' ');
      window.__plannedTokens = mapped;
    }
  </script>

  <script>
    const stopBtn = document.getElementById('stopBtn');

    function fingerspellWord(word){ const blocks = []; const upperWord = (word||'').toUpperCase(); for (const char of upperWord){ if (char >= 'A' && char <= 'Z'){ const lb = letterToSign.get(char); if (lb) blocks.push(lb); } } return blocks; }

    function buildSigml(tokens){
      const blocks = [];
      for (const t of tokens){
        const b = glossToSign.get(t);
        if (b) { blocks.push(b); }
        else if (letterToSign.size > 0) { const lb = fingerspellWord(t); if (lb.length > 0){ blocks.push(...lb); log(`Fingerspelling: "${t}"`); } }
      }
      if (!blocks.length) return null;
      return `<?xml version="1.0" encoding="utf-8"?>\n<sigml>\n${blocks.join('\n')}\n</sigml>`;
    }

    function playSigml(sigml){ try{ CWASA.playSiGMLText(sigml, 0); }catch(e){ log('CWASA play error: ' + e); } }

    const translateBtn = document.getElementById('translateBtn');
    translateBtn?.addEventListener('click', async () => {
      if (!window.CWASA) { renderStatus.textContent = 'CWASA not loaded.'; return; }
      translateBtn.disabled = true;
      try {
        renderStatus.textContent = 'Translating‚Ä¶';
        renderStatus.className = 'status-badge loading';
        await doPlan('spacy');
        const toks = window.__plannedTokens || [];
        if (!toks.length) { renderStatus.textContent = 'No tokens planned.'; renderStatus.className = 'status-badge'; return; }
        const sigml = buildSigml(toks);
        if (!sigml) { renderStatus.textContent = 'No matching signs.'; renderStatus.className = 'status-badge'; return; }
        renderStatus.textContent = 'Playing‚Ä¶';
        renderStatus.className = 'status-badge loading';
        playSigml(sigml);
        setTimeout(() => { renderStatus.textContent = 'Ready'; renderStatus.className = 'status-badge ready'; }, 500);
      } catch (e) { console.error(e); renderStatus.textContent = 'Translate error.'; renderStatus.className = 'status-badge'; }
      finally { translateBtn.disabled = false; }
    });

    stopBtn.addEventListener('click', () => { try{ CWASA.stop(0); renderStatus.textContent = 'Stopped'; renderStatus.className = 'status-badge'; }catch(_e){} });
  </script>

  <script>
    const recordBtn = document.getElementById('recordBtn');
    const transcribeBtn = document.getElementById('transcribeBtn');
    const micStatus = document.getElementById('micStatus');
    const transcription = document.getElementById('transcription');
    const langHint = document.getElementById('langHint');

    let mediaRecorder = null;
    let recordedChunks = [];

    function pickAsrModel(){ const ua = navigator.userAgent||''; const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(ua); return isMobile ? 'Xenova/whisper-tiny.en' : 'Xenova/whisper-small'; }

    async function ensureASR(){
      const { pipeline } = window.transformers;
      const model = pickAsrModel();
      if (!window.__asr || window.__asrModelName !== model){ window.__asr = await pipeline('automatic-speech-recognition', model); window.__asrModelName = model; }
      return window.__asr;
    }

    recordBtn.addEventListener('click', async () => {
      if (!mediaRecorder){
        try{
          const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
          recordedChunks = [];
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          mediaRecorder.ondataavailable = (e)=>{ if(e.data.size>0) recordedChunks.push(e.data); };
          mediaRecorder.onstop = ()=>{ stream.getTracks().forEach(t=>t.stop()); };
          mediaRecorder.start();
          recordBtn.textContent = '‚ñ† Stop recording';
          recordBtn.classList.remove('btn-secondary'); recordBtn.classList.add('btn-primary');
          micStatus.textContent = 'Recording‚Ä¶'; micStatus.className = 'status-badge loading';
        }catch(e){ micStatus.textContent = 'Mic error: ' + e; }
      } else {
        mediaRecorder.stop(); mediaRecorder = null;
        recordBtn.textContent = '‚óè Start recording';
        recordBtn.classList.remove('btn-primary'); recordBtn.classList.add('btn-secondary');
        micStatus.textContent = `Recorded ${(recordedChunks.reduce((s,b)=>s+b.size,0)/1024/1024).toFixed(1)} MB`; micStatus.className = 'status-badge';
      }
    });

    transcribeBtn.addEventListener('click', async () => {
      if (!recordedChunks.length){ micStatus.textContent = 'Nothing recorded.'; return; }
      micStatus.textContent = 'Loading ASR model‚Ä¶'; micStatus.className = 'status-badge loading';
      try{
        const asr = await ensureASR();
        micStatus.textContent = 'Transcribing‚Ä¶';
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        const result = await asr(blob, { chunk_length_s: 30, stride_length_s: 5 });
        transcription.value = (result?.text||'').trim();
        textIn.value = transcription.value;
        micStatus.textContent = 'Done ‚úì'; micStatus.className = 'status-badge ready';
      }catch(e){ micStatus.textContent = 'Error: ' + e; micStatus.className = 'status-badge'; }
    });
  </script>

  <script>
    const videoFile = document.getElementById('videoFile');
    const videoToSignBtn = document.getElementById('videoToSignBtn');
    const videoStatus = document.getElementById('videoStatus');

    async function ensureFFmpeg(){
      if (!window.__ffmpeg){ const { createFFmpeg, fetchFile } = FFmpeg; const ffmpeg = createFFmpeg({ log: false }); await ffmpeg.load(); window.__ffmpeg = { ffmpeg, fetchFile }; }
      return window.__ffmpeg;
    }

    videoToSignBtn.addEventListener('click', async () => {
      const file = videoFile?.files?.[0];
      if (!file){ videoStatus.textContent = 'Choose a video first.'; return; }
      try{
        videoStatus.textContent = 'Preparing ffmpeg‚Ä¶'; videoStatus.className = 'status-badge loading';
        const { ffmpeg, fetchFile } = await ensureFFmpeg();
        videoStatus.textContent = 'Extracting audio‚Ä¶';
        ffmpeg.FS('writeFile', 'in', await fetchFile(file));
        await ffmpeg.run('-i', 'in', '-vn', '-ac', '1', '-ar', '16000', '-f', 'wav', 'out.wav');
        const data = ffmpeg.FS('readFile', 'out.wav');
        const wavBlob = new Blob([data.buffer], { type: 'audio/wav' });
        videoStatus.textContent = 'Loading ASR model‚Ä¶';
        const asr = await ensureASR();
        videoStatus.textContent = 'Transcribing‚Ä¶';
        const result = await asr(wavBlob, { chunk_length_s: 30, stride_length_s: 5 });
        const text = (result?.text||'').trim();
        transcription.value = text;
        videoStatus.textContent = 'Planning‚Ä¶';
        textIn.value = text;
        await doPlan('spacy');
        videoStatus.textContent = 'Ready to render ‚úì'; videoStatus.className = 'status-badge ready';
      }catch(e){ videoStatus.textContent = 'Error: ' + e; videoStatus.className = 'status-badge'; }
    });
  </script>

  <script>
    const openaiKey = document.getElementById('openaiKey');
    const saveKeyBtn = document.getElementById('saveKeyBtn');
    if (openaiKey) openaiKey.value = localStorage.getItem('openai_key') || '';
    saveKeyBtn?.addEventListener('click', () => { const v = openaiKey.value.trim(); if (v){ localStorage.setItem('openai_key', v); log('Saved OpenAI key locally.'); } else { localStorage.removeItem('openai_key'); log('Cleared OpenAI key.'); } });
  </script>

  <script>
    function log(msg){
      const el = document.getElementById('planLog');
      const now = new Date().toLocaleTimeString();
      if (!el) return;
      const prev = el.textContent ? (el.textContent + '\n') : '';
      el.textContent = prev + `[${now}] ${msg}`;
    }
  </script>

  <script>
    window.addEventListener('error', e => { log('JS error: ' + (e?.error?.message || e.message)); });
    window.addEventListener('unhandledrejection', e => { log('Promise rejection: ' + (e?.reason?.message || e.reason)); });
  </script>

</body>
</html>
